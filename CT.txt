Together
52860.0
53720.0
And maybe we'll come back.
59690.0
2170.010101010101
I guess there is no.
7930.010101010101
9580.0101010101
It's the final down.
21890.010101010103
23960.010101010103
With that
28830.0101010101
30330.0101010101
Let's talk about some review.
31000.010101010103
32780.0101010101
So.
34310.0101010101
35210.0101010101
This is going to go fairly quick.
35960.0101010101
37550.0101010101
It took about 1/2 hour last lecture and
37550.0101010101
40360.010101010106
I think that's about all there is to
40360.010101010106
41609.0101010101
say.
41610.010101010106
42190.010101010106
So.
43960.0101010101
44760.010101010106
We will start with.
46020.0101010101
47550.0101010101
So.
53720.010101010106
54320.0101010101
We covered everything up until single
56250.0101010101
59140.0101010101
source shortest path or the shortest
59140.0101010101
1130.0202020202019
path algorithm.
1130.0202020202019
1860.020202020202
So I've got today to talk about
1860.020202020202
4436.020202020202
shortest path algorithms on flow and
4436.020202020202
9070.020202020203
finally bloom filters.
9070.020202020203
10280.020202020201
The things that you have not been
10280.020202020201
11580.020202020203
tested on.
11580.020202020203
12440.020202020201
Everything else we've already talked
12440.020202020201
13596.020202020203
about as much as I'm going to though at
13596.020202020203
15615.020202020203
the end I'll be happy to stay and
15615.020202020203
17030.020202020205
answer any questions people have.
17030.020202020205
18520.0202020202
So first Dykstra is right.
19390.0202020202
21090.0202020202
It's a wonderful algorithm.
21090.0202020202
22960.020202020205
And it's fairly easy to understand.
23840.0202020202
25630.0202020202
First of all, it was a very simple
25630.0202020202
27450.0202020202
translation from PRIMS, but
27450.0202020202
30120.020202020205
fundamentally Dijkstra's algorithm
30120.020202020205
31930.0202020202
seeks to find the shortest path from
31930.0202020202
35280.020202020205
one source to all other points on the
35280.020202020205
37910.0202020202
graph, which sounds like a lot, but it
37910.0202020202
40610.020202020205
does this very efficiently and it
40610.020202020205
43320.020202020205
doesn't efficiently because it assumes
43320.020202020205
45750.020202020205
that it is looked at all paths up to a
45750.020202020205
48700.020202020205
certain distance.
48700.020202020205
50320.020202020205
So it starts out when you pick the
50320.020202020205
52803.0202020202
source that has looked at all paths.
52803.0202020202
54870.0202020202
Of length zero and everything else is
54940.0202020202
57410.0202020202
Infinity.
57410.0202020202
58080.0202020202
And it then says, OK, we're going to
58840.0202020202
1430.030303030303
look at when we process that zero path.
1430.030303030303
4270.030303030303
We're going to look at all its
4270.030303030303
5850.030303030303
neighbors and find the shortest path,
5850.030303030303
8860.030303030304
including these new edges, right?
8860.030303030304
10950.030303030304
And so here we see it finds the 10 and
11840.030303030304
14985.030303030304
12 distance.
14985.030303030304
15970.030303030302
And then it says we're going to expand
15970.030303030302
18410.030303030304
the 10.
18410.030303030304
19850.0303030303
Right, because that's the next shortest
20870.030303030304
22840.030303030304
path.
22840.030303030304
23320.030303030304
And then we're going to expand the 12,
24550.030303030304
26690.0303030303
because the distance here was 18 here,
26690.0303030303
30010.0303030303
we're not showing the computing along
30010.0303030303
33175.030303030304
the way.
33175.030303030304
33720.030303030304
We're showing only the final points,
33720.030303030304
37370.030303030304
but it's very efficient.
37370.030303030304
38514.030303030304
What's wrong with it?
38514.030303030304
40732.0303030303
What's wrong with it is in its default
40732.0303030303
44840.030303030304
state.
44840.030303030304
45715.030303030304
It does not handle.
45715.030303030304
47920.030303030304
Negative weights and when we talk about
51260.030303030304
54036.030303030304
Dijkstra's in this class and in general
54036.030303030304
56670.030303030304
we mean dykstra's in its traditional
56670.030303030304
59540.030303030304
form.
59540.030303030304
59980.030303030304
So.
1910.040404040404
2810.040404040404
After I realized this won't work that
3580.040404040404
5750.040404040404
way, they can't write on these slides
5750.040404040404
8130.040404040404
anyways.
8130.040404040404
8850.040404040405
So what does Dykstra in its traditional
10800.040404040405
12770.040404040405
form look like?
12770.040404040405
13825.040404040405
Here it is right?
13825.040404040405
14910.040404040403
And what we've changed this little bit
14910.040404040403
16570.040404040406
down here.
16570.040404040406
17370.040404040403
To change it from prims?
18300.040404040406
19780.040404040403
And the little bit we changed was
21130.040404040403
22900.040404040403
instead of looking at only the lightest
22900.040404040403
26260.040404040403
edge and seeing if that is shorter.
26260.040404040403
29080.040404040403
We look at the edge plus the distance
30080.040404040403
32720.040404040403
to the start of that edge, right?
32720.040404040403
34640.0404040404
And so that is a total distance and if
34640.0404040404
39230.0404040404
it is shorter we update the total
39230.0404040404
41960.0404040404
distance and.
41960.0404040404
42990.04040404041
Its predecessor
43750.0404040404
44700.0404040404
With that, we're finding the shortest
47010.0404040404
48810.04040404041
path, and as I said, the key idea here
48810.04040404041
51560.04040404041
is that.
51560.04040404041
52560.04040404041
Paths that we're finding can only get
53380.04040404041
57170.04040404041
longer, right?
57170.04040404041
58140.0404040404
That we started looking at short paths
59160.0404040404
1303.050505050505
and since we are adding paths as they
1303.050505050505
4800.050505050505
get longer and we're adding the
4800.050505050505
8130.050505050505
shortest path we can find that goes to
8130.050505050505
11200.050505050505
a new place.
11200.050505050505
12070.050505050505
But that is longer than any other path
13390.050505050505
15360.050505050505
we've seen, or at least as long.
15360.050505050505
17280.050505050505
They can only get longer, and for that
18420.050505050505
20715.050505050505
to be true we cannot have negative
20715.050505050505
22640.050505050505
edges because then this shortest path
22640.050505050505
25210.0505050505
to somewhere could get shorter right?
25210.0505050505
27470.050505050505
Whereas to get anywhere we first have
27470.050505050505
29545.050505050505
to walk to the edge of our world and
29545.050505050505
31733.050505050505
then walk more.
31733.050505050505
33030.0505050505
It can only get longer.
33030.0505050505
34410.05050505051
OK.
35770.05050505051
36300.05050505051
The other thing is to remember this is
38210.0505050505
40290.0505050505
how we have always written the
40290.0505050505
41490.0505050505
pseudocode.
41490.0505050505
42440.05050505051
But these lines hiding something, isn't
43190.05050505051
45400.05050505051
it right?
45400.05050505051
46420.0505050505
On line 20, it looks like we're
46420.0505050505
48060.0505050505
updating an array.
48060.0505050505
49100.0505050505
But we're updating a value that causes
50280.0505050505
52490.0505050505
our priority queue to be updated, and
52490.0505050505
55760.05050505051
so that's possibly taking a lot of
55760.05050505051
57420.0505050505
work.
57420.0505050505
57930.0505050505
If we use a traditional priority queue
58830.05050505051
2890.060606060606
with updates, this is taking log N work
2890.060606060606
5970.060606060606
right.
5970.060606060606
6340.060606060606
But if we use a Fibonacci heap, which
7430.060606060606
10990.060606060606
we discussed but didn't implement.
10990.060606060606
13960.060606060606
It's only taking constant time because
14890.060606060606
17490.060606060604
the Fibonacci heap has one special
17490.060606060604
19440.060606060604
value, which I didn't remind you of
19440.060606060604
22270.060606060608
when talking about.
22270.060606060608
23540.060606060608
Or spanning trees, but it has the
24640.060606060604
26520.060606060608
special feature that.
26520.060606060608
27940.060606060604
It has a function that will decrease
28560.060606060608
30480.060606060604
key.
30480.060606060604
30870.060606060604
That is to say increase the priority of
30870.060606060604
33990.06060606061
a key.
33990.06060606061
34590.0606060606
And they can do that change in constant
35390.06060606061
38010.06060606061
time.
38010.06060606061
38460.06060606061
Making the key be lower priority.
39360.06060606061
41325.0606060606
That takes work, but making the key be
41325.0606060606
44380.0606060606
higher priority.
44380.0606060606
45286.06060606061
That is to say, have a smaller value.
45286.06060606061
48070.06060606061
We can do that efficiently and with
48070.06060606061
50770.0606060606
Dykstra.
50770.0606060606
51140.06060606061
The only changes that ever happened is
51140.06060606061
53790.06060606061
that the nodes that we have not yet
53790.06060606061
56360.06060606061
visited we find shorter and shorter
56360.06060606061
59159.06060606061
paths for right.
59160.0606060606
270.07070707070704
They all started it Infinity.
270.07070707070704
2370.070707070707
And the only time they change is if we
3200.070707070707
6520.070707070708
find something shorter.
6520.070707070708
7610.070707070708
OK.
8790.070707070709
9210.070707070709
So.
11170.070707070707
12120.070707070709
That line 20 hides possibly a lot of
14960.070707070709
18130.070707070707
work.
18130.070707070707
18590.070707070707
But it could be managed by using the
19260.070707070707
22680.070707070707
correct data structure.
22680.070707070707
23970.070707070707
I could go through running through the
26510.070707070707
28310.070707070707
algorithm, but I think that seeing that
28310.070707070707
32135.07070707071
the one time was good enough right, we
32135.07070707071
34940.07070707071
keep going through and adding the
34940.07070707071
36553.07070707071
smallest node and adding the smallest
36553.07070707071
38119.07070707071
node.
38119.07070707071
38379.07070707071
And I will put a link to all these
40030.07070707071
41890.07070707071
slides up so you've got it.
41890.07070707071
43470.07070707071
So we end up with a couple of things to
46870.07070707071
49160.07070707071
review.
49160.07070707071
49530.07070707071
Ken Dykstra's handle.
49530.07070707071
52170.07070707071
An undirected graph.
53520.07070707071
54637.07070707071
We described it with a directed graph.
54637.07070707071
57310.07070707071
But yeah, we can easily handle an
57310.07070707071
59427.07070707071
undirected graph.
59427.07070707071
282.0808080808081
We just treat it as if there is an edge
282.0808080808081
3580.0808080808083
in both directions, right?
3580.0808080808083
5310.080808080807
So we update both ways, not a problem.
5310.080808080807
7570.080808080808
Can it handle a negative cycle well?
11440.080808080807
15300.08080808081
Can any shortest path handle a negative
16010.080808080807
18390.080808080806
cycle?
18390.080808080806
18760.08080808081
No, because it doesn't make sense
19520.08080808081
21210.080808080806
right?
21210.080808080806
22080.08080808081
If there's a negative cycle in my
22080.08080808081
23890.080808080806
graph.
23890.080808080806
24580.08080808081
The shortest path to any place that can
25980.080808080806
28910.080808080806
reach that negative cycle is go to the
28910.080808080806
32242.080808080806
negative cycle.
32242.080808080806
32850.08080808081
Do that as many times as you want and
33600.08080808081
36340.080808080806
then go to your destination.
36340.080808080806
37650.080808080806
And you can always be shorter by going
38480.080808080806
41680.08080808081
through the cycle one more time, so
41680.08080808081
44220.080808080806
there is no shortest path, right?
44220.080808080806
46710.08080808081
So that's important to remember that as
47460.08080808081
49140.08080808081
shortest path is not defined.
49140.08080808081
52130.080808080806
If we have a negative weight cycle, can
52130.080808080806
54805.08080808081
dykstra's do negative weight edges?
54805.08080808081
57390.08080808081
I've already said the default digesters
57390.08080808081
510.09090909090907
cannot, but we did discuss a small
510.09090909090907
3850.090909090909
change right in dykstra's.
3850.090909090909
6143.090909090909
We know we will look at each vertex.
6143.090909090909
9370.090909090908
We will add each vertex as the shortest
10140.09090909091
12860.090909090908
element once right, every time we go
12860.090909090908
16250.090909090908
through our loop, we are adding one
16250.090909090908
17890.090909090908
vertex.
17890.090909090908
19240.090909090908
We'll do that for every vertex.
19240.090909090908
20880.09090909091
When we're done, we will add it all the
20880.09090909091
23120.090909090908
vertices and we found the shortest path
23120.090909090908
25090.090909090908
to everywhere.
25090.090909090908
25640.090909090908
But we can simply change Dijkstra's in
26420.090909090908
28810.090909090908
a very small way.
28810.090909090908
30220.09090909091
We can say when we add a vertex that's
30970.09090909091
34760.090909090904
the shortest vertex, we know a path to
34760.090909090904
37790.090909090904
great.
37790.090909090904
38320.090909090904
We process it just and we update any
38320.090909090904
43315.09090909091
vertex, even if we have already seen
43315.09090909091
45720.090909090904
it.
45720.090909090904
46040.090909090904
With a path that's shorter.
46910.09090909091
49470.090909090904
If we do that, we run Intel.
50970.090909090904
53550.09090909091
There are no vertices to visit until
53550.09090909091
56300.09090909091
our priority queue is empty.
56300.09090909091
57920.09090909091
And then we're done.
58700.09090909091
59750.090909090904
Cool.
1040.1010101010102
1690.1010101010102
So that's a very small change, but it
2940.10101010101
4870.10101010101
changes our analysis right in the sick
4870.10101010101
8570.10101010101
dykers the one that we talked about,
8570.10101010101
10760.10101010101
the one that Dykstra defined you have
10760.10101010101
13630.101010101009
this feature that you will go through
13630.101010101009
16055.101010101009
that loop exactly as many times as
16055.101010101009
18810.10101010101
their vertices, because every time
18810.10101010101
20720.10101010101
through the loop.
20720.10101010101
21479.10101010101
You add 1 vertex and you will never
22280.10101010101
25620.10101010101
revisit it.
25620.10101010101
26430.101010101007
With modified Dijkstra's, you have no
27160.10101010101
29880.10101010101
such guarantee and we did not do the
29880.10101010101
32800.10101010101
analysis of modified Dijkstra's because
32800.10101010101
35220.10101010101
it isn't really important because
35220.10101010101
37820.10101010101
fundamentally there are no better ways
37820.10101010101
43080.10101010101
but in general.
43080.10101010101
44490.10101010101
This negative weight edges there are
46080.10101010101
47400.10101010101
lots of different things we can apply.
47400.10101010101
49190.10101010101
OK, so that's what I've got to say
50110.10101010101
52320.10101010101
about digesters.
52320.10101010101
53180.10101010101
Yeah I should.
55710.10101010101
56440.10101010101
Running times, this is the one we talk
57850.101010101
10.11111111111111
about N log N + M.
10.11111111111111
2200.1111111111113
That's the one that is known that
2200.1111111111113
5100.111111111111
requires a Fibonacci heap or a similar
5100.111111111111
7780.111111111111
heap that has constant time reduce
7780.111111111111
13190.111111111111
increased priority.
13190.111111111111
14440.111111111111
If we do it with our basic data
16500.11111111111
18200.11111111111
structure, we get M log N.
18200.11111111111
20590.11111111111
OK.
22610.11111111111
23030.11111111111
Last thing to say in this that is not
24460.11111111111
27550.11111111111
likely to really show up on the final
27550.11111111111
29270.11111111111
but wasn't big impact for people in the
29270.11111111111
32020.111111111113
projects is.
32020.111111111113
33560.11111111111
If you're doing dykstra's, you have a
34610.11111111111
36380.11111111111
real problem.
36380.11111111111
37470.11111111111
Because the standard priority queues
38130.11111111111
40480.11111111112
you're given.
40480.11111111112
41220.11111111111
Don't actually have update, so the
42150.11111111111
44350.11111111111
standard template library has a heap
44350.11111111111
46490.11111111111
priority queue.
46490.11111111111
47790.11111111111
That heap is the very one we
47790.11111111111
49410.11111111112
implemented right where we use an
49410.11111111112
51360.11111111111
array.
51360.11111111111
51920.11111111111
What's the problem with that?
53090.11111111112
54960.11111111111
The problem.
56980.11111111112
57920.11111111111
Is that with an array?
58890.11111111111
59775.11111111111
I don't know where my vertex is right?
59775.11111111111
2820.121212121212
It's somewhere in the array, so to
2820.121212121212
6230.121212121212
update it I would have to potentially
6230.121212121212
8240.121212121212
search the whole array.
8240.121212121212
9380.121212121212
We kind of tricked you because in the
10580.121212121212
12440.121212121212
lab we had you do updates right?
12440.121212121212
14470.121212121212
But that's because we controlled
14470.121212121212
16370.121212121212
exactly.
16370.121212121212
16845.121212121212
We knew where things would be.
16845.121212121212
18760.121212121212
And we just wanted you to see the idea,
19790.121212121212
21900.121212121212
O, if you could figure out the vertex
21900.121212121212
23900.121212121212
you want to update, you can do updates
23900.121212121212
26720.121212121212
of priority in log N time either by
26720.121212121212
29600.121212121212
heapify or heapify down.
29600.121212121212
31320.121212121212
But the trick is, how do you find the
32520.121212121212
34510.121212121216
vertex?
34510.121212121216
35150.121212121216
Well, if this is a feature you want to
35150.121212121216
37720.121212121216
support in general, you then implement
37720.121212121216
40270.12121212121
a priority queue using pointers instead
40270.12121212121
43270.12121212121
of using the array solution.
43270.12121212121
44860.121212121216
It's very straightforward change, and
44860.121212121216
47687.121212121216
then since the memory location storing
47687.121212121216
51970.121212121216
any value in the priority queue doesn't
51970.121212121216
54310.12121212121
change, just the pointers to its
54310.12121212121
57760.121212121216
parents and children.
57760.121212121216
59250.121212121216
It's fine.
350.1313131313131
1030.1313131313132
Everything works the same, the
1680.1313131313132
3000.131313131313
algorithms the same, we just have to
3000.131313131313
4640.131313131313
play with pointers instead of array
4640.131313131313
6780.131313131313
indexing.
6780.131313131313
7360.131313131313
OK.
8560.131313131313
8950.131313131313
But that wasn't it for shortest paths.
10750.131313131313
13630.131313131313
We also talked about an algorithm.
13630.131313131313
15510.131313131313
Floyd warshall.
15510.131313131313
17010.131313131315
I love this thing because you can write
17010.131313131315
20545.131313131315
this code in about 10 minutes if you
20545.131313131315
22920.131313131315
already have a graph, right?
22920.131313131315
24680.13131313131
If someone else has provided you the
24680.13131313131
26500.13131313131
graph implementation implementing Floyd
26500.13131313131
29166.131313131315
Warshall.
29166.131313131315
29819.13131313131
This practically drops in and becomes
31300.131313131315
34050.13131313131
C.
34050.13131313131
34715.131313131315
You could probably just copy this in.
34715.131313131315
37200.131313131315
Have the compiler scream at you and
37200.131313131315
38880.131313131315
figure out what the debug right when I
38880.131313131315
41979.131313131315
was much younger.
41980.131313131315
42930.131313131315
Some people I knew took when there were
42930.131313131315
46460.131313131315
lots of language programming classes.
46460.131313131315
48393.131313131315
They took Fortran, COBOL, basic and see
48393.131313131315
52540.131313131315
all at the same time they had the same
52540.131313131315
54700.131313131315
assignments.
54700.131313131315
55410.131313131315
They wrote them in one language and
55410.131313131315
57170.131313131315
then just debugged them by dumping them
57170.131313131315
58840.131313131315
into the others.
58840.131313131315
59730.131313131315
We don't recommend this in general, but
1150.141414141414
3790.1414141414143
straightforward.
3790.1414141414143
4505.141414141414
It's not that hard to convert.
4505.141414141414
7910.141414141414
So why is it interesting?
8680.141414141413
11060.141414141413
First of all.
11750.141414141413
13860.141414141415
Floyd Warshall
14530.141414141415
15720.141414141415
Handily automatically by itself,
16420.141414141417
18690.141414141413
handles negative weight edges, that's
18690.141414141413
20190.141414141413
nice.
20190.141414141413
20650.141414141417
But it's also interesting in that.
21560.141414141413
23810.141414141413
It's the first in this class concrete
24690.141414141413
26880.141414141413
example of dynamic programming.
26880.141414141413
29090.141414141413
It's a dynamic programming algorithm.
30940.141414141413
32780.14141414141
What do I mean by that?
32780.14141414141
33800.14141414141
I mean, it builds in from on
33800.14141414141
35870.14141414141
information of previous iterations, so
35870.14141414141
38750.14141414142
the first time we go through this loop
38750.14141414142
41940.14141414141
right, we initialize the world and we
41940.14141414141
45510.14141414141
know the shortest path from anywhere to
45510.14141414141
49110.14141414141
anywhere that consists only of the
49110.14141414141
52699.14141414141
start and the end.
52700.14141414141
53850.14141414141
Right?
54740.14141414141
55130.14141414141
That's exactly the cost of the edges.
55970.14141414141
58960.14141414141
We're done.
480.1515151515152
1070.151515151515
We've we've solved that sub problem.
1070.151515151515
4620.151515151515
We go on with Floyd Warshall.
6170.151515151515
8480.151515151516
And.
9440.151515151514
10190.151515151514
We now look through.
11160.151515151516
14090.151515151514
The path that includes.
15600.151515151514
19030.151515151516
The first value in our implementation.
20020.151515151516
23010.151515151516
In this case a.
24170.151515151516
25730.151515151516
So it includes the beginning of the end
25730.151515151516
28720.151515151512
in A and we've now solved that sub
28720.151515151512
32210.151515151516
problem.
32210.151515151516
32850.15151515152
And we know those values.
34130.15151515152
35560.15151515152
Those may be the shortest path, they
35560.15151515152
37500.15151515151
may not.
37500.15151515151
38140.15151515151
It isn't clear how it's being dynamic
39680.15151515151
42520.15151515152
programming yet, how it's building on
42520.15151515152
43980.15151515151
sub problems.
43980.15151515151
44890.15151515151
But then.
46420.15151515152
47310.15151515152
We look at the next one, and here we're
49530.15151515152
53210.15151515151
writing it as if it is the start, the
53210.15151515151
56110.15151515151
end and B.
56110.15151515151
57310.15151515152
But in fact it's solving all possible
58230.15151515151
2220.161616161616
paths that are the start the end and A
2220.161616161616
6034.161616161616
or B or A&amp;B in between.
6034.161616161616
9480.161616161617
Right, because it computes, what if I
10400.161616161617
15680.161616161617
included be in the path?
15680.161616161617
17230.16161616162
Is it better?
17230.16161616162
18170.161616161615
If so, let's do it.
18970.161616161615
21450.161616161615
Otherwise, we'll stick with something
21450.161616161615
23680.161616161615
we had.
23680.161616161615
24446.16161616162
We already had the shortest path of.
24446.16161616162
27140.16161616162
Nothing of nothing in a now we say,
27970.161616161615
32600.161616161615
well, what about B?
32600.161616161615
34690.16161616162
But this B implicitly includes a path
34690.16161616162
39309.16161616162
to B involving A and implicitly
39310.16161616162
43317.16161616161
includes a path from B involving a.
43317.16161616161
47719.16161616161
So we now have found that and we could
49160.16161616162
53290.16161616162
think of this triply nested loop as a
53290.16161616162
55430.16161616162
huge recursion.
55430.16161616162
56680.16161616162
Right where we would say recursively we
57370.16161616162
450.17171717171715
want to find the shortest path.
450.17171717171715
2090.1717171717173
Our recursion would look for shortest
2090.1717171717173
4170.171717171717
paths missing one thing and go down.
4170.171717171717
6960.171717171717
The base of that recursion we would
7750.171717171717
9462.171717171717
have the shortest path involving
9462.171717171717
11570.171717171717
nothing but the start and the end, and
11570.171717171717
13660.171717171717
then one up we would have involving a
13660.171717171717
16720.171717171717
involving B involving C involving D
16720.171717171717
20620.171717171717
right?
20620.171717171717
21130.171717171717
All of those are already computed, and
22120.171717171717
24455.171717171717
we build up and we build up and we
24455.171717171717
27388.171717171717
build up.
27388.171717171717
28039.171717171714
And the trick is we don't need extra
28970.171717171717
30700.171717171717
space because we only care about
30700.171717171717
33540.17171717172
keeping track of the shortest one.
33540.17171717172
35360.17171717172
Right, we don't need all of the
36080.17171717172
37540.17171717172
possible sub problems.
37540.17171717172
39130.17171717172
We only need the shortest sub problem
39130.17171717172
41850.17171717172
solution we found between the start and
41850.17171717172
44625.17171717172
the end.
44625.17171717172
45050.17171717172
So I think that's really cool.
47200.17171717172
49990.17171717172
It's a nice algorithm.
49990.17171717172
52290.17171717172
Why do we like it?
52290.17171717172
53690.17171717172
If we compare it to dykstra's.
54640.17171717172
57830.17171717172
It's iffy what I like man, it's so much
59340.17171717172
2850.1818181818185
easier to code than diestrus.
2850.1818181818185
4290.181818181818
And your time matters.
5240.181818181818
7070.181818181818
If I really need all the points.
9030.181818181818
11480.181818181818
Is it better than dykstra's?
13750.181818181818
15330.181818181818
Not quite.
15330.181818181818
16340.181818181818
By graph has a lot of edges right?
17130.181818181816
20200.181818181816
Because Dijkstra's has this term here.
20200.181818181816
23250.18181818182
That is.
24370.18181818182
25260.181818181816
There's about the edges, the M term,
26830.181818181816
29460.18181818182
and if that term is large, as in the
29460.18181818182
32530.181818181816
number of edges are on the order of N
32530.181818181816
35570.181818181816
squared, then.
35570.181818181816
37570.181818181816
Oh
38490.181818181816
38870.181818181816
That's north squared.
39820.181818181816
40950.181818181816
And in a concrete actual application,
42410.181818181816
45700.181818181816
it has another disadvantage.
45700.181818181816
47660.181818181816
Arrays are nice compact data
48530.181818181816
50510.18181818182
structures, and going through an array
50510.18181818182
52660.181818181816
in a nice, predictable manner is good
52660.181818181816
56080.18181818182
for cash performance.
56080.18181818182
57810.181818181816
Dykstra is just it's touching
57810.181818181816
40.1919191919192
everything.
40.1919191919192
335.1919191919192
It's hopping around.
335.1919191919192
1233.1919191919192
It's going.
1233.1919191919192
1779.1919191919192
Hey, I'm only going to do the work I
1780.1919191919192
3540.191919191919
need to do, and that's great.
3540.191919191919
6120.19191919192
Except for if the computer is already
7030.19191919192
9360.191919191919
getting all of the work, you don't need
9360.191919191919
11190.191919191919
to do.
11190.191919191919
11720.191919191919
It doesn't really help you as much.
12490.191919191919
14280.191919191919
So cash is make Floyd Warshall happy
15880.191919191919
20200.19191919192
and dykstra's sad.
20200.19191919192
22370.191919191922
And finally of course.
22370.191919191922
24550.191919191922
Floyd Warshall automatically handles
25180.19191919192
27480.19191919192
negative edges if we redo dykstra's
27480.19191919192
31570.19191919192
with negative edges are problem becomes
31570.19191919192
34820.19191919192
that loop bound is possibly worse.
34820.19191919192
39010.191919191915
And everything gets bad because the
39720.19191919192
42480.191919191915
loop bound of M ends up over here.
42480.191919191915
45390.19191919192
That every edge could potentially
46570.19191919192
48740.19191919192
update the thing and could return the
48740.19191919192
51810.19191919192
vertex.
51810.19191919192
52560.19191919192
So OK.
53240.19191919192
55610.19191919192
So if we need negative weight edges,
57060.19191919192
59050.191919191915
it's useful, and if we need.
59050.191919191915
1170.2020202020203
You deal with large things with a lot
2380.2020202020203
6100.20202020202
of edges, it's useful.
6100.20202020202
7260.20202020202
OK, that's what we did for shortest
8360.202020202021
10480.20202020202
path.
10480.20202020202
11010.202020202021
Neither are terribly hard, both are, I
12330.20202020202
15490.20202020202
think, fairly easy to understand.
15490.20202020202
17380.20202020202
Floyd Warshall I think is trivial to
18090.20202020202
20170.202020202018
understand the code.
20170.202020202018
21430.20202020202
Really, wrapping your head around the
22220.20202020202
23870.202020202018
concept is a little bit more
23870.202020202018
25330.20202020202
challenging.
25330.20202020202
25980.20202020202
That's OK.
27240.20202020202
27850.202020202018
So then we talked about network flow.
29290.20202020202
31180.20202020202
Right and we said OK, look.
32280.202020202018
34760.20202020202
It's spent one day sort of working
34760.20202020202
36775.20202020202
through the algorithm and then a bunch
36775.20202020202
38770.20202020202
of time working through the proof.
38770.20202020202
40460.20202020202
And the answer is you don't have to
41080.20202020202
42940.20202020202
remember the proof, so that's nice from
42940.20202020202
45300.20202020202
a test point of view, but I thought it
45300.20202020202
47220.20202020202
was kind of interesting and getting
47220.20202020202
49650.20202020202
comfortable with the ideas and the
49650.20202020202
51183.202020202014
proof will help you in 374.
51183.202020202014
53010.20202020202
Not because they going to do the same
53810.20202020202
55070.20202020202
thing, but they're going to do similar
55070.20202020202
56400.20202020202
kinds of ideas so.
56400.20202020202
59200.20202020202
Flow problem of Max flow is trying to
570.2121212121211
3030.2121212121215
solve what is the flow from 1 vertex in
3030.2121212121215
7610.212121212121
a graph that's traditionally directed
7610.212121212121
9910.21212121212
to another?
9910.21212121212
10900.21212121212
OK, we call that a flow network.
11960.212121212122
15470.212121212122
The first thing we do is we need to
16340.212121212122
18460.21212121212
talk about what is the flow on a path.
18460.21212121212
21250.212121212124
Here we have the path AB, CF.
22040.21212121212
25150.21212121212
What's the flow?
25970.21212121212
26900.21212121212
Let's do we can figure out the flow of
29060.21212121212
31080.21212121212
a BCF.
31080.21212121212
31960.21212121212
It's 3, right?
34040.21212121212
35450.21212121212
Because the flow, the most material or
36210.21212121212
40130.21212121212
water or whatever I can put through
40130.21212121212
42460.21212121212
those connections is equal to the
42460.21212121212
44990.21212121213
smallest choke point, right?
44990.21212121213
47190.21212121212
If I try to put four in, sure it goes.
47190.21212121212
49710.21212121212
Here it goes here and then it goes.
49710.21212121212
51019.21212121212
And get stopped.
52480.21212121212
53390.21212121212
So we get three and DEF.
54520.21212121212
57002.21212121212
We get def.
57002.21212121212
59060.21212121213
We get 7 or I think that was actually
59810.21212121213
3570.222222222222
supposed to be a DF.
3570.222222222222
6520.222222222223
No, it was.
8670.222222222223
9660.222222222223
To get five, it must have been
14430.22222222222
15990.222222222223
replacing CF with DEF.
15990.222222222223
19930.222222222223
Forgive me.
19930.222222222223
20890.22222222222
I'm using slides that have been done by
20890.22222222222
22905.222222222223
TA's for review in past semesters, so
22905.222222222223
26210.222222222223
again, we can compute that.
26210.222222222223
28870.222222222223
Pretty cool.
30060.222222222223
31050.222222222223
And then how did we compute the flow?
32720.22222222222
34453.222222222226
We kept picking paths until we there
34453.222222222226
37840.222222222226
were no more paths, right?
37840.222222222226
39430.22222222222
We computed the flow and this works
39430.22222222222
42390.22222222222
great and we could look at these things
42390.22222222222
44190.222222222226
and say let's see this one, it was.
44190.222222222226
47770.222222222226
I think we got.
54220.22222222222
55350.22222222222
Look
58640.22222222222
59230.222222222226
We got 10.
670.2323232323232
1860.2323232323233
And we got 20.
2720.2323232323233
3770.2323232323233
I did it right in my head.
4930.232323232322
6090.232323232323
OK.
7540.232323232323
8230.232323232323
And our choke points end up being CF.
9890.232323232323
13550.232323232323
And DE.
14200.232323232323
15230.232323232323
Over here, our choke points are well
16370.232323232322
19230.23232323232
either AB and AC.
19230.23232323232
21420.23232323232
Or BD and CD.
22340.232323232325
25330.23232323232
But there was a problem here, right
27500.232323232325
30300.23232323232
when we looked at this second graph, it
30300.23232323232
33300.232323232325
could make bad choices, right?
33300.232323232325
34990.23232323232
That I could choose.
36550.232323232325
37820.232323232325
Hey, I'm gonna pick a random flow and
37820.232323232325
39830.232323232325
the first flow I'm gonna pick is ABCD.
39830.232323232325
43540.232323232325
Right, and so I flow 5 units.
44490.23232323232
47600.232323232325
But I've consumed 5 of this.
48430.232323232325
51450.23232323232
And that means I can only because the
52470.232323232325
55356.232323232325
path AC has no other exit to get to D
55356.232323232325
640.2424242424242
the path AC can only flow 5 and that's
640.2424242424242
4800.242424242424
reduced the total we can flow out of
4800.242424242424
6755.242424242424
the origin.
6755.242424242424
7320.242424242425
Right, so how did we fix it?
8630.242424242424
10670.242424242424
Well?
10670.242424242424
11240.242424242424
The first thing we did was we said,
12000.242424242424
14060.242424242424
hey.
14060.242424242424
14540.242424242424
Let's do something fancier.
15630.242424242424
17320.242424242424
Instead of removing flows from the
17320.242424242424
19500.242424242424
graph when we remove a flow, we're
19500.242424242424
23120.242424242424
going to add a backwards flow, right?
23120.242424242424
25230.242424242424
Which is a way of letting the algorithm
25230.242424242424
27980.242424242424
kind of undo its mistake.
27980.242424242424
29640.242424242424
We said if we have a backwards flow, we
30340.242424242428
33340.242424242424
can just each keep adding flows that
33340.242424242424
36336.242424242424
will happen is that backwards flow will
36336.242424242424
38960.242424242424
get undone O when we flowed from A to
38960.242424242424
41897.242424242424
B&amp;B to C&amp;C to D we said now.
41897.242424242424
44640.242424242424
The Edge BC is all used up, but there's
45390.242424242424
49420.242424242424
an edge.
49420.242424242424
50160.242424242424
CB with a capacity of five.
50950.242424242424
54810.242424242424
And that edge can be used to undo the
56160.242424242424
59460.242424242424
mistake.
59460.242424242424
100.25252525252525
OK.
1370.2525252525252
1790.2525252525252
So that's cool.
3260.2525252525256
4260.252525252526
But it takes time.
5040.252525252526
6205.252525252526
We showed that as long as we have
6205.252525252526
7999.252525252526
integers, it ends because every time we
8000.252525252526
11300.252525252525
run a flow we have increased the total
11300.252525252525
13830.252525252527
flow.
13830.252525252527
14250.252525252525
And with integers after a certain
15400.252525252527
17370.252525252527
number of integers, we'll get to any
17370.252525252527
18910.252525252523
fixed integer.
18910.252525252523
19850.252525252527
And since flow is going to be a fixed
19850.252525252527
21960.252525252523
value, that was cool.
21960.252525252523
23510.252525252527
But then we said, hey.
24860.252525252527
26190.252525252527
We could do something better.
27100.252525252527
28590.252525252523
We could be smarter.
28590.252525252523
30210.252525252523
About how we pick our edges right?
31120.252525252527
33050.25252525252
And there were two ways we could be
34320.25252525253
35890.25252525253
smarter.
35890.25252525253
36450.25252525252
We could pick edges that were the
37560.25252525252
40300.25252525252
largest path, right?
40300.25252525252
42110.25252525253
So if we flowed, the most possible for
42110.25252525253
44810.25252525252
example here, we could pick a BD or a
44810.25252525252
48820.25252525253
CD, but we could not pick a BCD.
48820.25252525253
52290.25252525252
Both of them, because both of those two
53170.25252525252
54950.25252525252
are larger.
54950.25252525252
55550.25252525252
They're 10 versus 5.
55550.25252525252
57110.25252525253
Then it would work and we wouldn't have
57820.25252525253
59210.25252525253
to worry about the backwards.
59210.25252525253
430.2626262626262
We still need the backwards because
1360.2626262626263
2930.2626262626263
there's much more complicated graphs
2930.2626262626263
5600.262626262626
you'll still need the backwards, but
5600.262626262626
6830.262626262626
it's more efficient.
6830.262626262626
7750.262626262626
We said, OK, that's one, but it's a
8610.262626262625
11530.262626262625
little complicated to figure out the
11530.262626262625
13240.262626262627
largest path, right?
13240.262626262627
14860.262626262625
We said another thing we could do is
14860.262626262625
17720.26262626263
just choose the shortest path and
17720.26262626263
19750.262626262625
number of edges, and again that would
19750.262626262625
22260.262626262625
allow Abd and a CD.
22260.262626262625
25740.262626262625
And then that was what our whole proof
26680.262626262625
28585.262626262625
was showing.
28585.262626262625
29650.262626262625
That's really good.
29650.262626262625
31565.262626262625
That is an algorithm that guarantees
31565.262626262625
34650.26262626262
things converge very quickly.
34650.26262626262
36330.26262626262
We don't care about the details, but
37290.26262626262
39270.26262626263
understanding that those two choices as
39270.26262626263
41790.26262626262
heuristics instead of picking a
41790.26262626262
43880.26262626263
completely random path, greatly improve
43880.26262626263
46645.26262626263
the algorithm.
46645.26262626263
47500.26262626262
Things that would not picking the path
47500.26262626262
50290.26262626262
with the largest single edge.
50290.26262626262
54060.26262626263
It's not necessarily good, right?
55200.26262626263
56690.26262626262
The path ABC D has an edge of 10.
57750.26262626262
2420.272727272727
Picking a path with the longest path,
3760.2727272727275
8430.272727272728
clearly bad, et cetera.
8430.272727272728
10740.272727272726
OK.
11580.272727272726
11960.272727272728
So that's really all we had to do on
12890.272727272726
14410.272727272726
flow.
14410.272727272726
15000.272727272728
That's the only amount I want you to
15000.272727272728
16910.272727272728
understand is sort of how to run the
16910.272727272728
18530.272727272728
basic algorithm.
18530.272727272728
20150.272727272728
Why back edges are there, how they're
20150.272727272728
23340.272727272728
used to fix things, and what are good
23340.272727272728
26000.272727272728
heuristics for path choice.
26000.272727272728
27460.272727272728
That's the only things we could ask
28230.272727272728
29530.272727272728
about on their final.
29530.272727272728
31350.272727272728
And finally, Brad talked about Bloom
33870.27272727273
36348.27272727273
filters.
36348.27272727273
36782.27272727273
Bloom filters are super cool and it's
36782.27272727273
39730.27272727273
the first time we've covered them.
39730.27272727273
40980.27272727273
Bloom filters really want to use very
42850.27272727272
46110.27272727273
little space to store a huge amount of
46110.27272727273
48520.27272727273
data.
48520.27272727273
48940.27272727273
And they also want to be very fast.
49740.27272727273
51550.27272727273
And so their idea is kind of well.
52230.27272727273
54420.27272727273
Let's have a hash table.
55220.27272727273
56530.27272727272
But instead of storing all those values
57470.27272727273
59860.27272727273
and things, we're just going to store.
59860.27272727273
2038.2828282828282
Is there something here or not, right?
2038.2828282828282
4860.282828282828
So what we're storing?
4860.282828282828
6530.282828282829
Either there's something here or there
6530.282828282829
8871.282828282829
is not, so it's true or false.
8871.282828282829
11320.282828282829
And when we insert we go to every hash
12100.282828282829
16640.282828282827
value.
16640.282828282827
17250.282828282827
We take our data and we hash it and we
18570.282828282827
21069.282828282827
set it to one.
21070.282828282827
21840.282828282827
If it's zero, it goes to one.
22620.282828282827
24153.28282828283
If it's one, it goes to 1, right?
24153.28282828283
25750.282828282827
We cannot remove from a basic bloom
27770.282828282827
29890.282828282827
filter because we have no way of
29890.282828282827
32470.282828282827
knowing if that being is that hash
32470.282828282827
35200.28282828283
value is set to 1 because we inserted
35200.28282828283
39490.28282828283
the thing that we want to remove or we
39490.28282828283
41475.28282828283
inserted something else.
41475.28282828283
42600.28282828283
OK.
43790.28282828283
44400.28282828283
So one of the promise when we look at a
46770.282828282834
51790.28282828283
data structure answering a question, a
51790.28282828283
54722.28282828283
data structure has four possible
54722.28282828283
56680.28282828283
outcomes to an answer of a question,
56680.28282828283
58450.28282828283
right?
58450.28282828283
58940.28282828283
It can say yes, this thing is true.
58940.28282828283
1700.292929292929
Here's the answer.
1700.292929292929
3369.2929292929293
No, it is false.
3370.2929292929293
6290.292929292929
And we are correct.
7020.292929292929
8190.29292929293
It could accidentally say.
9220.29292929293
10940.29292929293
Sure, I've got that information and be
10940.29292929293
13290.29292929293
completely wrong, or it could say.
13290.29292929293
16670.29292929293
That doesn't exist and be completely
17390.29292929293
20000.29292929293
wrong, right?
20000.29292929293
20810.29292929293
These are the four things we can have
20810.29292929293
22680.29292929293
happen.
22680.29292929293
23100.29292929293
If our data structure is not 100%
23780.29292929293
26400.29292929293
correct, which is the case of bloom
26400.29292929293
28720.29292929293
filters, right?
28720.29292929293
29410.29292929293
They can be wrong.
29410.29292929293
30630.29292929293
But one of these bloom filters cannot.
31770.29292929293
34900.29292929293
What is it that cannot be true from a
36110.29292929293
38220.29292929293
bloom filter?
38220.29292929293
38850.292929292926
Yeah.
38850.292929292926
39320.29292929293
A bloom filter cannot have a false
41540.29292929293
44090.292929292926
negative that if I've inserted
44090.292929292926
46880.292929292926
something.
46880.292929292926
47570.29292929293
It is definitely got a one on it right?
48600.292929292926
51600.292929292926
If I have not inserted it.
51600.292929292926
54160.292929292926
It might have a 0, but something else
54950.292929292926
58560.292929292926
might have hashed to that value.
58560.292929292926
730.3030303030304
So we might say, yeah, that's here.
730.3030303030304
2320.3030303030305
But we cannot have it not be here.
3870.30303030303
6110.30303030303
So with that information we said, can
7550.303030303031
10085.30303030303
we make bloom filters a little bit more
10085.30303030303
11920.30303030303
accurate?
11920.30303030303
12430.30303030303
And instead of using 1 hash value.
13380.30303030303
15940.30303030303
We're going to use multiple hash
17150.30303030303
19380.30303030303
values, right?
19380.30303030303
20301.303030303032
We're going to hash the thing that we
20301.303030303032
23080.303030303032
want to put in, or check in the bloom
23080.303030303032
25380.30303030303
filter with several different hash
25380.30303030303
27980.303030303032
functions.
27980.303030303032
28640.303030303032
And will check all those locations on
29260.303030303032
32340.303030303032
insert we will set the mall to one and
32340.303030303032
35357.30303030303
on search checking if there we will
35357.30303030303
38400.30303030303
look at all of them.
38400.30303030303
39906.30303030303
If any of them are zero the answer is
39906.30303030303
42060.30303030303
no.
42060.30303030303
42410.30303030303
It's not here, but if they're all one,
42410.30303030303
44870.303030303025
the answer is yes and this improves.
44870.303030303025
48580.30303030303
Our performance in general and it's
49360.30303030303
53290.30303030303
basically banking on this idea that it
53290.30303030303
55960.30303030303
can't have a false negative.
55960.30303030303
59630.30303030303
So.
1480.3131313131312
3930.3131313131316
This kind of comp incomprehensible
5110.313131313132
7840.313131313131
function, which you don't have to
7840.313131313131
9460.313131313133
memorize, describes the chances.
9460.313131313133
12640.313131313133
Assuming sue haha.
13760.31313131313
15260.31313131313
But what's interesting about it?
15260.31313131313
17050.31313131313
What's interesting, right?
17950.31313131313
19230.31313131313
We have the.
19230.31313131313
21470.31313131313
M is the size of our vector that we're
22600.313131313134
25830.31313131313
storing our bloom filter in.
25830.31313131313
27300.31313131313
K is the number of hash functions.
28090.31313131313
30770.31313131313
And N is the number of things we
31530.31313131313
34180.31313131314
insert, right?
34180.31313131314
35140.31313131313
And what's interesting here is OK, both
36250.31313131314
39450.31313131313
makes this bigger and smaller.
39450.31313131313
42560.31313131313
So as I use more and more hash
43680.31313131314
47450.31313131313
functions, I get more and more accurate
47450.31313131313
50050.31313131313
until kind of I'm filling in the whole
50050.31313131313
52947.31313131313
table, right?
52947.31313131313
53730.31313131313
If I have 100 hash functions and a
53730.31313131313
56848.31313131313
table with only ten locations, I'm just
56848.31313131313
190.3232323232323
going to color the whole table as true.
190.3232323232323
2350.3232323232323
The first thing I insert.
2350.3232323232323
4050.3232323232323
And now I am almost always having false
4990.323232323232
7830.323232323232
negatives or false positives, right?
7830.323232323232
10310.323232323233
Because everything's gonna say it's
10310.323232323233
11590.323232323233
there no problem.
11590.323232323233
12320.323232323233
But if I only have 1 hash function.
13610.323232323231
15600.323232323231
I can end up with the chance of having
17750.323232323233
21910.323232323233
a false.
21910.323232323233
22700.323232323233
A positive is exactly one over the size
23490.32323232323
26500.323232323233
of the table.
26500.323232323233
27240.32323232323
Right, because I assume my hash
27980.323232323233
29970.32323232323
functions are suha.
29970.32323232323
31040.323232323233
So there's this curve we get.
32100.323232323233
33770.32323232324
And what does this mean?
34730.32323232323
35860.32323232323
This means that we reduce that
35860.32323232323
39750.32323232323
complicated mass to this optimal point.
39750.32323232323
43340.32323232323
You don't actually have to memorize
44160.32323232323
45530.32323232324
this function either, but you should
45530.32323232324
46960.32323232324
remember sort of what's going on with
46960.32323232324
48620.32323232323
it that this optimal point says that
48620.32323232323
53830.32323232323
for a given number of keys and a given
53830.32323232323
56509.32323232323
size of.
56510.32323232323
58040.32323232323
Table we have a optimal number of
58920.32323232324
2264.3333333333335
insertions for an expected number of
2264.3333333333335
5131.333333333333
insertions expected in a given size of
5131.333333333333
8223.333333333332
table.
8223.333333333332
8537.333333333332
We have an optimal number of hash
8537.333333333332
10710.333333333332
functions for a given, number, of,
10710.333333333332
13539.333333333334
etcetera.
13540.333333333332
14020.333333333334
So we can solve for any two of these.
14020.333333333334
16870.333333333336
We can figure out the best choice of
16870.333333333336
18576.333333333336
the third cool.
18576.333333333336
20540.333333333332
When designing your hash function your
22070.333333333336
24830.333333333332
bloom filters you want to base on this
24830.333333333332
27250.333333333332
OK.
27250.333333333332
27700.333333333332
Finally, we talked about one
30300.333333333336
32260.333333333336
improvement over a classical bloom
32260.333333333336
34455.333333333336
filter, which was a counting bloom
34455.333333333336
36480.333333333336
filter.
36480.333333333336
36850.33333333333
And the counting bloom filter.
38020.333333333336
39375.33333333333
We want to be able to ask how many
39375.33333333333
41400.333333333336
different things did we see or how many
41400.333333333336
44430.33333333333
things of this type did we see, right?
44430.33333333333
46270.333333333336
Of this set of things, and this gives
47360.333333333336
51510.333333333336
us some features.
51510.333333333336
52565.333333333336
This says that instead of storing true
52565.333333333336
54980.333333333336
or false, we'll store a count, right.
54980.333333333336
58590.333333333336
This makes it use more space.
58590.333333333336
870.3434343434343
But
2150.3434343434346
2980.3434343434346
It makes it mean that we have an idea
4510.343434343435
7580.343434343434
of how many different things we saw.
7580.343434343434
9360.343434343435
OK, that seems useful.
10610.343434343435
12500.343434343435
It also allows us to kind of remove,
14490.343434343435
18100.343434343435
right?
18100.343434343435
19470.343434343435
It's not perfect.
19470.343434343435
20840.343434343435
But we now have a way of removing
21560.343434343435
23880.343434343435
because all we're going to do is
23880.343434343435
25250.343434343435
decrement the count if we have put two
25250.343434343435
27720.343434343435
things in that collided.
27720.343434343435
29140.343434343435
And we decrement and we remove one of
29800.343434343435
31610.343434343435
them.
31610.343434343435
31896.343434343435
We decrement the count by 1, and that's
31896.343434343435
34090.343434343435
a reasonable approximation.
34090.343434343435
36030.343434343435
Unfortunately, we then no longer have
37090.343434343435
40840.343434343435
the promise that we cannot have false
40840.343434343435
43330.343434343435
negatives.
43330.343434343435
43940.343434343435
So it's a trade off and it depends on
44750.343434343435
47050.343434343435
your application design.
47050.343434343435
48600.343434343435
What do you want to do?
48600.343434343435
49970.343434343435
There isn't a right answer here, right?
49970.343434343435
52050.343434343435
We can decide one thing or the other.
52740.343434343435
55110.343434343435
But it gives us a useful feature.
56900.343434343435
58860.343434343435
And that's it for what we're going to
59730.343434343435
1430.3535353535353
cover on bloom filters.
1430.3535353535353
2690.3535353535353
We're not going to cover on the sketch
3470.3535353535353
6200.353535353535
stuff.
6200.353535353535
6650.353535353535
We felt that there was a little bit too
7330.353535353535
9060.353535353535
much probability and we didn't give
9060.353535353535
10490.353535353535
enough background to test that.
10490.353535353535
12150.353535353535
But even with it's a cool application
12950.353535353535
15830.353535353535
that has some really interesting ideas.
15830.353535353535
17740.353535353534
So as I said, I'll put this link up,
19080.353535353534
21860.353535353537
but the last thing I wanna play is what
21860.353535353537
24945.353535353537
this little bit that a.
24945.353535353537
27270.353535353537
Past TA did that.
27960.353535353537
30810.353535353534
I think is amazing.
32370.353535353537
34340.35353535353
He was a grad student when I was still
39110.35353535353
40460.35353535353
a grad student, so.
40460.35353535353
41320.35353535353
Heads up, our final is coming soon.
45560.35353535353
48066.35353535353
1/3 of your entire grade.
48066.35353535353
50950.35353535353
It's really important.
50950.35353535353
52660.35353535353
We are here to help you study.
52660.35353535353
55220.35353535354
So let's go over hashing first, then
55220.35353535354
57990.35353535353
arrange with the hash function.
57990.35353535353
59810.35353535353
H deterministic fall for should be all
59810.35353535353
4124.363636363636
of one.
4124.363636363636
4992.363636363637
You should remember Sue haha.
4992.363636363637
7300.363636363636
Uniform distribution.
9770.363636363638
12340.363636363636
Visions 1-2 keys hash into the same
19290.363636363636
22900.363636363636
spot.
22900.363636363636
23400.363636363636
Separate chaining makes all this stuff
28670.363636363636
31175.363636363636
all your room.
31175.363636363636
32340.363636363632
You must free hash items may not go to
34830.36363636363
37770.36363636363
the same place that they were before
37770.36363636363
40610.36363636364
and that is hashing.
40610.36363636364
43290.36363636364
Let's move on.
43290.36363636364
44370.36363636363
Thanks.
50590.36363636363
51170.36363636364
Heaps the priority queues Intertan move
54090.36363636363
57657.36363636363
our log in time from route to the
57657.36363636363
470.3737373737374
leaves is always increasing.
470.3737373737374
3960.373737373737
There are we stopping our and log in
3960.373737373737
7980.373737373738
one is over then so make sure these is
7980.373737373738
12220.373737373737
clear they fest this joint sets also
12220.373737373737
15270.373737373737
might be.
15270.373737373737
16070.373737373739
So let's see.
19890.373737373735
20930.37373737374
OK, start out at minus one and merge if
22910.37373737374
26370.373737373735
they are not in nothing that so
26370.373737373735
29380.37373737374
carefully.
29380.37373737374
31200.37373737374
Union by height.
33440.37373737374
34550.37373737374
You can be union by size and if you do
34550.37373737374
38240.37373737374
it right, three efficiency will be
38240.37373737374
40830.37373737374
maximized.
40830.37373737374
41830.37373737374
You should use path compression, it
41830.37373737374
43965.37373737374
gets you up the constant time your tree
43965.37373737374
47740.37373737374
gets shorter with every single call to
47740.37373737374
50610.37373737373
find and just like that made amazed
50610.37373737373
54510.37373737374
figure it out, disjoint sets and all
54510.37373737374
56560.37373737374
your MP seven days.
56560.37373737374
58800.37373737374
Therefore, we're moving on to graphs.
59680.37373737373
2740.3838383838383
Questions are about weighted wraps.
24450.383838383837
27540.383838383837
These kids get their own swimming pool.
27540.383838383837
30620.383838383837
You can use cross schools and door
30620.383838383837
32890.38383838384
Prins.
32890.38383838384
33360.38383838384
It doesn't matter which one.
33360.38383838384
35830.38383838384
They both create a tree with small this
35830.38383838384
38520.38383838384
total weight.
38520.38383838384
40070.38383838384
You'd better and hold the difference
40820.38383838384
42690.38383838384
between our B&amp;D DFS and which
42690.38383838384
46600.383838383845
implementation will suit your graph.
46600.383838383845
49173.383838383845
The best adjacency matrix sore list,
49173.383838383845
53070.38383838384
which one will make your graph run the
53070.38383838384
55020.38383838384
fastest without any tricks?
55020.38383838384
57420.383838383845
Which is n + m plus up if you want the
58350.383838383845
1930.3939393939393
shortest path from S2 N, like through
1930.3939393939393
5970.393939393939
the algorithm is surely the way to go.
5970.393939393939
9700.393939393938
Need to get this tree is to have all
11060.39393939394
13760.39393939394
your graph edges being weighted
13760.39393939394
15570.39393939394
positively.
15570.39393939394
16700.39393939394
And that's all I've got.
17730.393939393936
21310.39393939394
Good luck on your exam.
21860.39393939394
23480.393939393936
